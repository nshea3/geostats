---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

# 1. Loading Data

### Data loaded into dataframe

```{r}

rm(list=ls())

coal_df = read.csv(file = 'dataset_Nicholas-Tony.csv')

```
# 2. Mean and Variance of each variable


### Thickness

```{r}
cat("Mean thickness: ", mean(coal_df$Thickness))
cat("\nVariance of thickness: ", var(coal_df$Thickness))
```


### Accumulation

```{r}
cat("Mean accumulation: ", mean(coal_df$Accumulation))
cat("\nVariance of accumulation: ", var(coal_df$Accumulation))
```

Very large variance, guaranteed negative values for accumulation if we are in the Gaussian case (infinite extent?) 
Since accumulation is a physical (nonnegative) quantity, we cannot have these distributions. Consistent with the given multimodal sum-of-Gaussians.

### Lignite Quality Index

```{r}
cat("Mean lignite quality: ", mean(coal_df$LQ))
cat("\nVariance of lignite quality: ", var(coal_df$LQ))
```

Only 29% of the observations have quality index 1. 79% have quality index 0. 
Variance matches Bernoulli RV with $p = 0.29$, $p(1-p) = 0.2059$.


# 3. Histograms of each variable

```{r}
hist(coal_df$Thickness, breaks = 10)
```
The curve is bell-shaped with a single mode around the average at 10. Negative skew. Median is 10.38, slightly higher than mean. 

Given model for Thickness is $\mu = 10$, $\sigma^2 = 4$.

Testing validity of given model with 1-sample Kolmogorov-Smirnov test:

```{r}
ks.test(coal_df$Thickness, pnorm, 10, 2)
```


```{r}
hist(coal_df$Accumulation, breaks=10)
```

Looks bimodal, one centered at low values with low variance.
Another with high mean with high dispersion. 

ANOVA?
t-Test?


```{r}

```



# 4. Conditional simulation of thickness T on discretization grid


Preparing the RGeostats db object

```{r}
library(RGeostats)

#Changing the quality index to avoid issue with 0 value

if (any(coal_df$LQ == 0)){
  coal_df$LQ = coal_df$LQ + 1
}


coal_db <- db.create(coal_df)

coal_db = db.locate(coal_db,3:4,"x")
coal_db = db.locate(coal_db,5,"z")

```


Simulating the thickness
Modeled as a Gaussian random function with parameters $\mu = 10$, $\sigma^2 = 4$.

```{r warning=FALSE}


sim_thickness <- function(indb, nsim = 1){
  
  indb = db.locate(indb, "Thickness", "z")
  
  Tmodel=model.create(vartype="Gaussian",range=20,sill=4,ndim=2)
  outdb = db.create(x0=c(0,0),dx=c(1,1),nx=c(200,100))
  neighb = neigh.create(ndim = 2, type = 0)
  simu <- simtub(nbtuba = 450, dbin=indb,dbout=outdb,model=Tmodel,neigh = neighb,mean = c(10), nbsimu = nsim)
  return(simu)

}

simu = sim_thickness(coal_db)

plot(simu)
plot(coal_db, add=T)
```


# 5. Conditional simulation of LQ (lignite quality index)

Modelled as a thresholded GRF with constant proportion 0.5. 
Underlying GRF is standard ($\mu = 0$ and $\sigma^{2} = 1$) and Gaussian covariance with range 50. 

First, update the 

```{r warning=FALSE}

props = table(coal_db[,"LQ"]) / coal_db$nsamples
props = c(0.5,0.5)
rule = rule.create(c("S", "F1", "F2"))
plot(rule, props=props, col=c("blue","yellow"), title="Lithotype Rule")
```

```{r warning=FALSE}


sim_lq <- function(indb, nsim = 1){
  
  indb = db.locate(indb, "LQ", "z")
  props = c(0.5,0.5)
  rule = rule.create(c("S", "F1", "F2"))
  voisin = neigh.create(type=0)
  outdb = db.create(x0=c(0,0),dx=c(1,1),nx=c(200,100))
  gaus = model.create("Gaussian", range=50)
  simlq = simpgs(dbout=outdb, dbin=indb, rule=rule,props=c(0.5, 0.5), model1=gaus, neigh = voisin, nbsimu = nsim)
  return(simlq)

}

simlq = sim_lq(coal_db)

plot(simlq)
plot(db.locate(coal_db, "LQ", "z"), add = T)
```


# 6. Conditional simulation of the accumulation A 

just continue with the simulation from before

Where $LQ(x) = 0$,  $\mu = 5000$ and $\sigma^{2} = 250000$

Where $LQ(x) = 1$, $\mu = 15000$ and $\sigma^{2} = 9\times10^6$.

Both have Gaussian covariance with range 10. 

```{r warning=FALSE}

sim_a0 <- function(indb, nsim=1){
  
  indb = db.locate(indb, "Accumulation", "z")
  
  #Selecting the data for condition
  coal_a0 = db.sel(indb, LQ==1)
  gaus_a0 = model.create("Gaussian", range=10, sill=250000)
  outdb = db.create(x0=c(0,0),dx=c(1,1),nx=c(200,100))
  neighb = neigh.create(ndim = 2, type = 0)
  sim =  simtub(dbin = coal_a0,dbout=outdb,model=gaus_a0,neigh = neighb,mean=5000, nbsimu = nsim)
  return(sim)
  
}


sima0 = sim_a0(coal_db)

plot(sima0, pos.legend=0)
plot(db.locate(coal_db, "Accumulation", "z"), add = T)
```
```{r warning=FALSE}

sim_a1 <- function(indb, nsim=1){
  
  db.locate(indb, "Accumulation", "z")
  coal_a1 = db.sel(indb, LQ==2)
  coal_a1 = db.locate(coal_a1,6,"z")
  gaus_a1 = model.create("Gaussian", range=10, sill=9000000)
  outdb = db.create(x0=c(0,0),dx=c(1,1),nx=c(200,100))
  neighb = neigh.create(ndim = 2, type = 0)
  sim_a1 =  simtub(dbin = coal_a1,dbout=outdb,model=gaus_a1,neigh = neighb,mean=15000, nbsimu = nsim)
  return(sim_a1)

}

sima1 = sim_a1(coal_db)

plot(sima1)
plot(db.locate(coal_db, "Accumulation", "z"),add=T)
```


```{r}

#Pull out vectors of simulated 
simulated_a0 = sima0@items$Simu.Accumulation.S1
simulated_a1 = sima1@items$Simu.Accumulation.S1

#Retrieve the simulated LQ index
#Turn into binary selector/mask
mask_1 = simlq@items$SimPGS.LQ.SFac1 - 1
#Reverse
mask_0 = 1 - mask_1

#Check - make sure the 
all(mask_0 + mask_1 == 1)

pw_map = mask_0 * simulated_a0 + mask_1 * simulated_a1


join_sims_zonal <- function(sim0, sim1, zones){
  
  mask_1 = zones - 1
  mask_0 = 1 - mask_1
  pw_map = mask_0 * sim0 + mask_1 * sim1
  return(pw_map)
  
}

simulated_a0 = sima0@items$Simu.Accumulation.S1
simulated_a1 = sima1@items$Simu.Accumulation.S1

jsim = join_sims_zonal(simulated_a0,simulated_a1,simlq@items$SimPGS.LQ.SFac1)

plot(db.locate(db.create(jsim,x0=c(0,0),dx=c(1,1),nx=c(200,100)),"jsim","z"))



```

# 7. Calorific value

Compute and plot the calorific value $C(x) = \frac{A(x)}{T(x)}$.

```{r}

cx = pw_map/simu@items$Simu.Thickness.S1

cxdb = db.create(cx,x0=c(0,0),dx=c(1,1),nx=c(200,100))
cxdb = db.locate(cxdb, 4, "z")
plot(cxdb)

```

# 8. Value of $C_{v}$ on each panel

Value of $C_{v}$ on each panel averaging over the 100 contained values. 

```{r warning=FALSE}
cgrid = db.create(x0=c(0,0),dx=c(10,10),nx=c(20,10))

plot(blockstat(cgrid, cxdb, fun='mean'))

panel_q =blockstat(cgrid, cxdb, fun='mean')
```

# 9. Quality tonnage and mean quality above cutoff curves

Quality tonnage and mean quality above cutoff for cut-off varying from 1000 to 2500. 

```{r}
hist(panel_q@items$Stats.mean)
```

Replicates the two modes, dispersion of the distribution. 


## The 

```{r}
sel = selectivity(panel_q, cuts = seq(1000,2500,50), flag.plot = F)

selectivity.curve(sel,"Z","T")
```

Interpreted in terms of the distribution, 
Obviously one iteration so it's not very 






```{r}
selectivity.curve(sel,"z","m")
```



# 10. Simulations of Calorific Value

100 simulations

```{r warning=FALSE}
sthicks = sim_thickness(coal_db, nsim = 100)
slqs = sim_lq(coal_db, nsim = 100)
sima0 = sim_a0(coal_db, nsim = 100)
sima1 = sim_a1(coal_db, nsim = 100)
```

Calculating statistics on individual simulations

```{r warning=FALSE}
for (idx in 4:103){
  thickn = sthicks@items[[idx]]
  simlq = slqs@items[[idx]]
  simulated_a0 = sima0@items[[idx]]
  simulated_a1 = sima1@items[[idx]]
  ajsim = join_sims_zonal(simulated_a0,simulated_a1,simlq)
  cx = ajsim/thickn
  cxdb = db.create(cx,x0=c(0,0),dx=c(1,1),nx=c(200,100))
  cxdb = db.locate(cxdb, 4, "z")
  
  cgrid = db.create(x0=c(0,0),dx=c(10,10),nx=c(20,10))
  panel_q = blockstat(cgrid, cxdb, fun='mean')
  
  sel = selectivity(panel_q, cuts = seq(1000,2500,50),flag.plot = F)
  
  if (idx == 4){
    
    sels = vector("list", 103)
    sels[[idx]] = sel
    
  } else {
    sels[[idx]] = sel

  }
}



Mmatrix = sels[[4]][,5]
Tmatrix = sels[[4]][,2]

for (idx in 5:103){
  Mmatrix = cbind(Mmatrix, sels[[idx]][,5])
  Tmatrix = cbind(Tmatrix, sels[[idx]][,2])
}

```


# 11. Empirical 95% Confidence Interval curves


Variance increaes with increasing grade?
Comment about variability matching the original distributions. (key feature of imulation)

```{r}

mmu = rowMeans(Mmatrix, na.rm = T, dims = 1)
plot(z, mmu, type = 'l')

mvar = apply(Mmatrix, 1, var, na.rm = T)
msd = sqrt(mvar)

lines(z, mmu + 1.96*msd, col="red")
lines(z, mmu - 1.96*msd, col="red")
```
```{r}
Tm = rowMeans(Tmatrix, na.rm = T, dims = 1)
plot(z, Tm, type = 'l')

Tvar = (Tsq / 100.0) - (Tm)**2
Tsd = sqrt(Tvar)


Tvar = apply(Tmatrix, 1, var, na.rm = T)
Tsd = sqrt(Tvar)

lines(z, Tm + 1.96*Tsd, col="red")
lines(z, Tm - 1.96*Tsd, col="red")
```


Decreases with increasing 
Drawing from two distributions to drawing from one
Smaller set of blocks 
Outweighs the larger variance of the higher grade blocks

